/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("easyChart", [], factory);
	else if(typeof exports === 'object')
		exports["easyChart"] = factory();
	else
		root["easyChart"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "../ccxtWrapper/CandleData.js":
/*!************************************!*\
  !*** ../ccxtWrapper/CandleData.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CandleData)\n/* harmony export */ });\nclass CandleData {\r\n    constructor(barArray) {\r\n        this.time = parseInt(barArray[0]);\r\n        this.open = parseFloat(barArray[1]);\r\n        this.high = parseFloat(barArray[2]);\r\n        this.low = parseFloat(barArray[3]);\r\n        this.close = parseFloat(barArray[4]);\r\n        this.vol = parseFloat(barArray[5]);\r\n        this.volFiat = parseFloat(barArray[6]);\r\n        this.otherInfo = {};\r\n        this.otherInfo.shapes = [];\r\n        this.barWidth = -1;\r\n\r\n        if (this.close === null) {\r\n            this.complete = false;\r\n        }\r\n        else {\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n}\n\n//# sourceURL=webpack://easyChart/../ccxtWrapper/CandleData.js?");

/***/ }),

/***/ "../ccxtWrapper/SymbolObj.js":
/*!***********************************!*\
  !*** ../ccxtWrapper/SymbolObj.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SymbolObj\": () => (/* binding */ SymbolObj)\n/* harmony export */ });\nclass SymbolObj {\r\n\r\n    constructor(asset1, asset2, exchange, market) {\r\n\r\n        //maybe do input validation, TODO later\r\n\r\n        this.exchange = exchange.trim();\r\n        this.asset1 = asset1.trim();\r\n        this.asset2 = asset2.trim();\r\n        this.market = market.trim();\r\n    }\r\n\r\n    getPairString() {\r\n        //return string form of the pair like \r\n        //BTC-USDT:SWAP\r\n        //return this.asset1 + \"-\" + this.asset2 + \"-\" + this.market;\r\n        //return this.asset1 + \"/\" + this.asset2 + \":\" + this.asset2;\r\n        return this.asset1 + this.asset2;\r\n    }\r\n\r\n    getPairStringForTicker(settleInSecondAsset) {\r\n        let setAsset = this.asset1;\r\n\r\n        if (settleInSecondAsset) {\r\n            setAsset = this.asset2;\r\n        }\r\n        //return this.asset1 + \"/\" + this.asset2 + \":\" + setAsset;\r\n        return this.asset1 + this.asset2;\r\n    }\r\n\r\n    getExchangeString() {\r\n        return this.exchange;\r\n    }\r\n}\n\n//# sourceURL=webpack://easyChart/../ccxtWrapper/SymbolObj.js?");

/***/ }),

/***/ "../ccxtWrapper/utility.js":
/*!*********************************!*\
  !*** ../ccxtWrapper/utility.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"utilities\": () => (/* binding */ utilities)\n/* harmony export */ });\n/* harmony import */ var _SymbolObj_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SymbolObj.js */ \"../ccxtWrapper/SymbolObj.js\");\n/* harmony import */ var _CandleData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CandleData.js */ \"../ccxtWrapper/CandleData.js\");\n\r\n\r\n\r\nconst utilities = {\r\n    getIntervalMSfromIntervalString(intervalString) {\r\n        if (intervalString === \"1m\") {\r\n            return 60000;\r\n        }\r\n\r\n        if (intervalString === \"5m\") {\r\n            return 5 * 60000;\r\n        }\r\n\r\n        if (intervalString === \"15m\") {\r\n            return 15 * 60000;\r\n        }\r\n\r\n        if (intervalString === \"30m\") {\r\n            return 30 * 60000;\r\n        }\r\n\r\n        if (intervalString === \"1h\") {\r\n            return 60 * 60000;\r\n        }\r\n\r\n        if (intervalString === \"4h\") {\r\n            return 4 * 60 * 60000;\r\n        }\r\n\r\n        if (intervalString === \"1d\") {\r\n            return 24 * 60 * 60000;\r\n        }\r\n\r\n        if (intervalString === \"1w\") {\r\n            return 7 * 24 * 60 * 60000;\r\n        }\r\n\r\n        if (intervalString === \"1M\") {\r\n            return 4 * 7 * 24 * 60 * 60000;\r\n        }\r\n\r\n        throw new Error(\"Invalid interval string : \" + intervalString);\r\n    },\r\n\r\n    createSymbol(pair1, pair2, exchange, market) {\r\n        if (!pair1 || !pair2 || !exchange || !market) {\r\n            throw new Error(\"symbol cannot be created, invalid parameters\");\r\n        }\r\n\r\n        return new _SymbolObj_js__WEBPACK_IMPORTED_MODULE_0__.SymbolObj(pair1, pair2, exchange, market);\r\n    },\r\n\r\n    /**\r\n     * This function converts array of string candlestick (olhcv) to object.\r\n     * @param {} array \r\n     * @returns \r\n     */\r\n    toNonStringObjMap(array) {\r\n        if (!(array instanceof Array)) {\r\n            throw new Error(\"the object to parse needs to be arrray.\");\r\n        }\r\n        let newArr = new Map();\r\n\r\n        array.forEach(element => {\r\n            var cls = new _CandleData_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](element);\r\n            newArr.set(cls.time, cls);\r\n        });\r\n\r\n        return newArr;\r\n    },\r\n\r\n    getReadableDate(milliseconds) {\r\n\r\n        // Create a new Date object using the milliseconds\r\n        const dateObject = new Date(milliseconds);\r\n\r\n        // Extract the various components of the date\r\n        const year = dateObject.getFullYear();\r\n        const month = dateObject.getMonth() + 1; // Months are zero-indexed, so add 1\r\n        const day = dateObject.getDate();\r\n\r\n        const hours = dateObject.getHours();\r\n        const minutes = dateObject.getMinutes();\r\n        const seconds = dateObject.getSeconds();\r\n\r\n        // Create a formatted date string\r\n        let formattedDate = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;\r\n\r\n        return formattedDate;\r\n    }\r\n}\r\n\r\n\n\n//# sourceURL=webpack://easyChart/../ccxtWrapper/utility.js?");

/***/ }),

/***/ "./js/candleRenderer.js":
/*!******************************!*\
  !*** ./js/candleRenderer.js ***!
  \******************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ candleRenderer)\n/* harmony export */ });\n/* harmony import */ var _ccxtWrapper_utility_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ccxtWrapper/utility.js */ \"../ccxtWrapper/utility.js\");\n/* harmony import */ var _models_CandleData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models/CandleData.js */ \"./js/models/CandleData.js\");\n/* harmony import */ var _ochlParser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ochlParser.js */ \"./js/ochlParser.js\");\n\r\n\r\n\r\n//SEE DOUBLE BUFFERING TECHNIQUE\r\nclass candleRenderer {\r\n    constructor(mainRenderer) {\r\n        this.canvas = mainRenderer.layredCanvas.addLayer(mainRenderer.candlestickLayerID, true, true);\r\n        this.backGroundCanvas = mainRenderer.layredCanvas.addLayer(mainRenderer.backgroundLayerID, true, true);\r\n        this.frontCanvas = mainRenderer.layredCanvas.addLayer(mainRenderer.candlestickLayerID + 1, true, true); //for \r\n        this.f1Canvas = mainRenderer.layredCanvas.addLayer(mainRenderer.candlestickLayerID + 2, false, false); // for price action\r\n\r\n        this.mainRenderer = mainRenderer;\r\n\r\n        this.dataToRender = undefined;\r\n        this.renderingOptions = undefined;\r\n\r\n        this.defaultRenderingOptions = {\r\n            halfBarWidth: 7,\r\n            gapSize: 14,\r\n            lowHiddenPixels: 0,\r\n            highHiddenPixels: 0,\r\n            lowOffsetPixels: 0,\r\n            highHiddenPixels: 0,\r\n            candleColor1: \"green\",\r\n            candleColor2: \"red\",\r\n            YZoomRate: 1,\r\n            candleStickBorderColor: 'black',\r\n            candleStickbgColor: null,\r\n            shapeDefaultVerticalSpacing: 5,//px\r\n        }\r\n\r\n        this.defaultRenderingOptions.barWidth = ((2 * this.defaultRenderingOptions.halfBarWidth) + 1 + this.defaultRenderingOptions.gapSize);\r\n        this.lastMouseHoverDate = Date.now();\r\n        this.mouseHoverFrameRate = 80;\r\n        this.isCanvasDragging = false;\r\n        this.newDataAdded = false;\r\n        this.lastHoverPosition = {};\r\n        // so whenever new data is added we can update rendering options.\r\n        this.createEvents();\r\n    }\r\n\r\n    createEvents() {\r\n        this.onMouseHover = this.onMouseHover.bind(this);\r\n        this.mainRenderer.layredCanvas.cvb1.addEventListener(\"mousemove\", this.onMouseHover);\r\n\r\n        this.draggingHasStopped = this.draggingHasStopped.bind(this);\r\n        document.addEventListener(\"mouseup\", this.draggingHasStopped);\r\n    }\r\n\r\n    draggingHasStopped() {\r\n        this.isCanvasDragging = false;\r\n    }\r\n\r\n    //convert different types of input to an object with oldest, current, interval and candleData.\r\n    //dont deal with replacing dataTorender etc, just prepare data\r\n    prepareDataAndSrc1(dataSrc) {\r\n        if (typeof dataSrc == typeof \"a\") {\r\n            try {\r\n                dataSrc = JSON.parse(dataSrc);\r\n                if (!Array.isArray(dataSrc)) {\r\n                    throw new Error(\"data source is not a JSON-array string\");\r\n                }\r\n            }\r\n            catch (e) {\r\n                console.log(e);\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (Array.isArray(dataSrc)) {\r\n            //convert it to map, coz we store it as a map.\r\n\r\n            if (dataSrc.length <= 0) {\r\n                console.log(\"No data to insert\");\r\n                return;\r\n            }\r\n\r\n            if (typeof dataSrc[0] == typeof 'a') {\r\n                dataSrc = (0,_ochlParser_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(dataSrc);\r\n            }\r\n\r\n            var _oldestTime;\r\n            var _currentTime;\r\n            var _intervalMS;\r\n            var _candleData = new Map();\r\n\r\n            if (dataSrc.length == 1) {\r\n                if (this.dataToRender) {\r\n                    _intervalMS = this.dataToRender.intervalMS;\r\n                }\r\n                else {\r\n                    _intervalMS = 0;\r\n                }\r\n\r\n                _oldestTime = dataSrc[0].time;\r\n                _currentTime = dataSrc[0].time;\r\n                _candleData.set(dataSrc[0].time, dataSrc[0]);\r\n\r\n            }\r\n            else {\r\n                _oldestTime = dataSrc[1].time > dataSrc[0].time ? dataSrc[0].time : dataSrc[dataSrc.length - 1].time;\r\n                _currentTime = dataSrc[1].time > dataSrc[0].time ? dataSrc[dataSrc.length - 1].time : dataSrc[0].time;\r\n                _intervalMS = Math.abs(dataSrc[0].time - dataSrc[1].time);\r\n\r\n                //convert the array into map\r\n                dataSrc.forEach(elem => {\r\n                    _candleData.set(elem.time, elem);\r\n                });\r\n            }\r\n\r\n            var newData = {\r\n                oldestDate: _oldestTime,\r\n                latestDate: _currentTime,\r\n                intervalMS: _intervalMS,\r\n                candleData: _candleData,\r\n            }\r\n            return newData;\r\n        }\r\n\r\n        //if data src is dataToRender object\r\n        if (dataSrc.candleData instanceof Map && dataSrc.oldestDate && dataSrc.latestDate && dataSrc.intervalMS && dataSrc.candleData.size > 1) {\r\n            return dataSrc;\r\n        }\r\n\r\n        if (dataSrc.oldestDate && dataSrc.latestDate && dataSrc.intervalMS && dataSrc.dataMap instanceof Map) {\r\n            var newData = {\r\n                oldestDate: dataSrc.oldestDate,\r\n                latestDate: dataSrc.latestDate,\r\n                intervalMS: dataSrc.intervalMS,\r\n                candleData: dataSrc.dataMap,\r\n            }\r\n\r\n            return newData;\r\n        }\r\n\r\n        if (dataSrc.constructor.name == \"CandleData\") {\r\n            let newData = {\r\n                oldestDate: dataSrc.time,\r\n                latestDate: dataSrc.time,\r\n                intervalMS: 0,\r\n                candleData: new Map(),\r\n                tickerData: {},\r\n            }\r\n            newData.candleData.set(dataSrc.time, dataSrc);\r\n\r\n            return newData;\r\n        }\r\n\r\n        //return it anyway\r\n        return dataSrc;\r\n    }\r\n\r\n    prepareDataAndSrc(dataSrc) {\r\n        if (!dataSrc) {\r\n            return;\r\n        }\r\n\r\n        //if data src is dataToRender object\r\n        if (dataSrc.candleData instanceof Map && dataSrc.oldestDate && dataSrc.latestDate && dataSrc.intervalMS && dataSrc.candleData.size > 1) {\r\n            return dataSrc;\r\n        }\r\n\r\n        //directly parsing coz i know data will be ordered\r\n        var newData = {\r\n            oldestDate: dataSrc.askedFromDate,\r\n            latestDate: dataSrc.askedToDate,\r\n            intervalMS: dataSrc.intervalMS,\r\n            candleData: dataSrc.data,\r\n        }\r\n        return newData;\r\n\r\n    }\r\n\r\n    //expose this method\r\n    appendDataSource(data) {\r\n        //first prepare the data\r\n        let readyData = this.prepareDataAndSrc(data);\r\n        if (!readyData) {\r\n            return;\r\n        }\r\n\r\n        if (!this.dataToRender) {\r\n            this.addNewDataSource(readyData);\r\n            return;\r\n        }\r\n        else {\r\n            if (this.dataToRender.intervalMS == 0) {\r\n                if (readyData.intervalMS != 0) {\r\n                    this.dataToRender.intervalMS = readyData.intervalMS\r\n                }\r\n                else {\r\n                    //find diference between two dates and thats the intervalMS\r\n                    this.dataToRender.intervalMS = Math.abs(readyData.latestDate - this.dataToRender.latestDate);\r\n                }\r\n            }\r\n            else {\r\n                if (readyData.intervalMS != 0 && readyData.intervalMS != this.dataToRender.intervalMS) {\r\n                    Error(\"Appending data has different interval, cannot append. Are you trying to add as new data source?\");\r\n                    return;\r\n                }\r\n            }\r\n\r\n            this.dataToRender.candleData = new Map([...this.dataToRender.candleData, ...readyData.candleData]);\r\n            this.dataToRender.oldestDate = this.dataToRender.oldestDate < readyData.oldestDate ? this.dataToRender.oldestDate : readyData.oldestDate;\r\n            this.dataToRender.latestDate = this.dataToRender.latestDate > readyData.latestDate ? this.dataToRender.latestDate : readyData.latestDate;\r\n            this.newDataAdded = true;\r\n        }\r\n\r\n        //only refresh if the added data is out of range.\r\n        this.refresh();\r\n    }\r\n\r\n    addNewDataSource(dataSrc) {\r\n\r\n        let readyData = this.prepareDataAndSrc(dataSrc);\r\n\r\n        if (!readyData) {\r\n            return;\r\n        }\r\n\r\n        this.clearCurrentDataSrc();\r\n        if (readyData.intervalMS == 0) {\r\n            if (readyData.candleData.get(readyData.candleData.oldestDate).isTicker)\r\n                this.unManagedData[tickerData] = readyData.candleData.get(readyData.candleData.oldestDate);\r\n        }\r\n        else {\r\n\r\n        }\r\n        this.dataToRender = readyData;\r\n\r\n        this.adjustYboundsInitially();\r\n        this.refresh();\r\n    }\r\n\r\n    //expose this method\r\n    updateTradeData(newTrade) {\r\n        //console.log(\"Ticker received\");\r\n        //no need to prepare ticker data.\r\n        if (!newTrade) {\r\n            return;\r\n        }\r\n\r\n        if (!this.dataToRender) {\r\n            console.log(\"Please add some bar data before adding trades/ticker.\");\r\n            return;\r\n        }\r\n\r\n        this.addLatestBar(newTrade);\r\n        this.updateCandlestick(newTrade);\r\n    }\r\n\r\n    addLatestBar(bar) {\r\n\r\n        if (bar.lastPrice) {\r\n            bar.lastPrice = parseFloat(bar.lastPrice);\r\n        }\r\n        console.log(\"Times are bar: \" + _ccxtWrapper_utility_js__WEBPACK_IMPORTED_MODULE_0__.utilities.getReadableDate(bar.time) + \" latest: \" + _ccxtWrapper_utility_js__WEBPACK_IMPORTED_MODULE_0__.utilities.getReadableDate(this.dataToRender.latestDate));\r\n        if (bar.time == this.dataToRender.latestDate) {\r\n            var lastState = this.dataToRender.candleData.get(bar.time);\r\n            bar.otherInfo = lastState.otherInfo;\r\n\r\n            bar.volume = bar.lastVolume + lastState.volume;\r\n            bar.open = lastState.open;\r\n            bar.high = lastState.high > bar.lastPrice ? lastState.high : bar.lastPrice;\r\n            bar.low = lastState.low < bar.lastPrice ? lastState.low : bar.lastPrice;\r\n            bar.close = bar.lastPrice;\r\n        }\r\n\r\n        if (this.dataToRender.latestDate < bar.time) {\r\n            console.log(\"New bar added of time : \" + bar.time.toString() + \" prev: \" + this.dataToRender.latestDate.toString());\r\n            this.dataToRender.latestDate += this.dataToRender.intervalMS;\r\n\r\n            if (this.renderingOptions.highOffsetPixels > 0) {\r\n                this.renderingOptions.highDate += this.dataToRender.intervalMS;\r\n                this.renderingOptions.highOffsetPixels -= this.renderingOptions.barWidth;\r\n                if (this.renderingOptions.highOffsetPixels < 0) {\r\n                    this.renderingOptions.highHiddenPixels = Math.abs(this.renderingOptions.highOffsetPixels);\r\n                    this.renderingOptions.highOffsetPixels = 0;\r\n                }\r\n            }\r\n\r\n            //new ticker\r\n            let prevCandle = this.dataToRender.candleData.get(bar.time - this.dataToRender.intervalMS);\r\n            if (!prevCandle) {\r\n                console.log(\"Ticker without candles??\");\r\n                debugger;\r\n            }\r\n            bar.volime = bar.lastVolume;\r\n            bar.open = prevCandle.close;\r\n            bar.close = bar.lastPrice;\r\n            bar.high = bar.close;\r\n            bar.low = bar.close;\r\n        }\r\n\r\n        this.dataToRender.candleData.set(bar.time, bar);\r\n        this.drawTickerPriceLine(bar.lastPrice);\r\n        //now also update the horizontal ticker price line.\r\n\r\n    }\r\n\r\n    //old version of add latest bar\r\n    addLatestBar2(bar) {\r\n        if (!bar || !this.dataToRender) {\r\n            return;\r\n        }\r\n        bar.close = bar.price;\r\n        if (bar.time == this.dataToRender.latestDate) {\r\n            let lastBar = this.dataToRender.candleData.get(bar.time);\r\n\r\n            //This is trade to trade update,, \r\n            bar.open = lastBar.open;\r\n\r\n            bar.high = bar.close > lastBar.high ? bar.close : lastBar.high;\r\n            bar.low = bar.close < lastBar.low ? bar.close : lastBar.low;\r\n\r\n            this.dataToRender.candleData.set(bar.time, bar);\r\n            console.log(\"Bar replaced..\");\r\n            return;\r\n        }\r\n\r\n        if (bar.time != this.dataToRender.latestDate + this.dataToRender.intervalMS) {\r\n            console.log(\"Not latest bar\");\r\n            return;\r\n        }\r\n\r\n        this.dataToRender.candleData.set(bar.time, bar);\r\n\r\n        if (bar.time > this.dataToRender.latestDate) {\r\n            let lastBar = this.dataToRender.candleData.get(this.dataToRender.latestDate);\r\n            this.dataToRender.latestDate = bar.time;\r\n            //this is new trade, previous bar is just ohlcv..\r\n            bar.high = bar.close;\r\n            bar.low = bar.close;\r\n            bar.open = lastBar.close;\r\n            console.log(\"New bar added..\");\r\n        }\r\n\r\n        if (this.renderingOptions.highOffsetPixels > 0) {\r\n            this.renderingOptions.highDate += this.dataToRender.intervalMS;\r\n            this.renderingOptions.highOffsetPixels -= this.renderingOptions.barWidth;\r\n            if (this.renderingOptions.highOffsetPixels < 0) {\r\n                this.renderingOptions.highHiddenPixels = Math.abs(this.renderingOptions.highOffsetPixels);\r\n                this.renderingOptions.highOffsetPixels = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    //expose this method\r\n    clearCurrentDataSrc() {\r\n        //clear everything\r\n        this.dataToRender = null;\r\n        this.renderingOptions = null;\r\n        //other variables too clear it.\r\n    }\r\n\r\n    //expose this method\r\n    refresh(newOptions) {\r\n        //redraw.\r\n        //clear the canvas and redraw\r\n        this.clearCandles();\r\n        this.setOrCreateRenderingOptions(newOptions);\r\n        this.plotAvailableData();\r\n    }\r\n\r\n    plotAvailableData() {\r\n        if (!this.dataToRender) {\r\n            return;\r\n        }\r\n\r\n        this.setOrCreateRenderingOptions();\r\n\r\n        if (!this.renderingOptions.Ylow || !this.renderingOptions.YHigh) {\r\n            //first time.\r\n            this.adjustYboundsInitially();\r\n        }\r\n\r\n        var tempLow = this.renderingOptions.lowDate;\r\n        var pos = this.renderingOptions.lowOffsetPixels - this.renderingOptions.lowHiddenPixels;\r\n\r\n        //this.canvas.cv1.style.display = \"none\";\r\n        while (tempLow <= this.renderingOptions.highDate) {\r\n            var pricee = this.dataToRender.candleData.get(tempLow);\r\n            this.drawACandleStick(pricee, { width: this.renderingOptions.barWidth, position: pos });\r\n            if (this.dataToRender.intervalMS == 0) {\r\n                break;\r\n            }\r\n            tempLow += this.dataToRender.intervalMS;\r\n            pos += this.renderingOptions.barWidth;\r\n            //console.log(\"CandleStick drawn\");\r\n        }\r\n\r\n        //this.canvas.cv1.style.display = \"inline-block\";\r\n\r\n        this.DrawBackgroundLines();\r\n    }\r\n\r\n    drawACandleStick(_priceInfo, _positionInfo) {\r\n        if (!_priceInfo) {\r\n            debugger;\r\n        }\r\n        var metricsInfo = this.calculateMetricsFromCandlestick(_priceInfo, _positionInfo);\r\n        var ctx = this.canvas.cv1.getContext(\"2d\");\r\n\r\n        if (_priceInfo.otherInfo.candleStickbgColor) {\r\n            ctx.fillStyle = _priceInfo.otherInfo.candleStickbgColor;\r\n            ctx.fillRect(metricsInfo.bodysx, 0,\r\n                _positionInfo.width, this.backGroundCanvas.cv1.height);\r\n        }\r\n\r\n        if (_priceInfo.otherInfo.shapes) {\r\n            //loop through and draw shapes above the candestick.\r\n            _priceInfo.otherInfo.shapes.forEach(element => {\r\n                if (element.name == \"upArrow\") {\r\n                    //Draw up arrow\r\n                    this.drawArrow(true, metricsInfo.wickx, metricsInfo.wickbottomy + element.margin, ctx, element.bodyColor);\r\n                }\r\n\r\n                if (element.name == \"downArrow\") {\r\n                    this.drawArrow(false, metricsInfo.wickx, metricsInfo.wicktopy - element.margin, ctx, element.bodyColor);\r\n                }\r\n\r\n                if (element.name == \"triangle\") {\r\n\r\n                }\r\n\r\n                if (element.name == \"circle\") {\r\n                    let radius = Math.floor(this.renderingOptions.barWidth / 2);\r\n\r\n                    if (element.aboveCandlestick) {\r\n                        this.drawCircle(metricsInfo.bodytopy - radius - element.margin, metricsInfo.wickx, element.bodyColor, radius, ctx);\r\n                    }\r\n                    else {\r\n                        this.drawCircle(metricsInfo.bodybtmy + radius + element.margin, metricsInfo.wickx, element.bodyColor, radius, ctx);\r\n                    }\r\n                }\r\n            });\r\n        }\r\n\r\n        ctx.fillStyle = _priceInfo.otherInfo.candleStickBodyColor ? _priceInfo.otherInfo.candleStickBodyColor : metricsInfo.color;\r\n        ctx.strokeStyle = ctx.fillStyle;\r\n        // draw wick\r\n        this.drawVerticalLine(ctx, metricsInfo.wickx, metricsInfo.wicktopy, metricsInfo.wickbottomy);\r\n\r\n        ctx.strokeStyle = _priceInfo.otherInfo.candleStickBorderColor ? _priceInfo.otherInfo.candleStickBorderColor : this.renderingOptions.candleStickBorderColor;\r\n        var strokeWidthOffset = 2; // stroking will increase the width by lineWidth px, i.e. 2 atm.\r\n        //draw body\r\n        this.drawRectangle(metricsInfo.bodysx, metricsInfo.bodytopy, metricsInfo.width - strokeWidthOffset, metricsInfo.bodybtmy - metricsInfo.bodytopy - strokeWidthOffset, ctx);\r\n\r\n        //draw any extra flag above the candlestick if provided.#TODO\r\n    }\r\n\r\n    //expose this method.\r\n    feedLiveData(liveData) {\r\n        if (!liveData) {\r\n            return;\r\n        }\r\n        if (liveData.isTrade) {\r\n            if (!liveData.time) {\r\n                if (!this.dataToRender) {\r\n                    console.log(\"Please add some bars first..\");\r\n                    return;\r\n                }\r\n                liveData.time = liveData.eventTime - (liveData.eventTime % this.dataToRender.intervalMS);\r\n            }\r\n\r\n            //dont parse, feed it, it will be parsed in updateTradeData and addLatestBar methods.\r\n            this.updateTradeData(liveData);\r\n        }\r\n\r\n        if (liveData.isCandle) {\r\n            if (!liveData.time) {\r\n                liveData.time = liveData.eventTime - (liveData.eventTime % this.dataToRender.intervalMS);\r\n            }\r\n\r\n            //parse\r\n            liveData = this.parseOLHC(liveData);\r\n\r\n            this.dataToRender.candleData.set(liveData.time, liveData);\r\n            this.dataToRender.latestDate = this.dataToRender.latestDate > liveData.time ? liveData.time : this.dataToRender.latestDate;\r\n            this.refresh();\r\n        }\r\n\r\n        if (liveData.isCandleStick) {\r\n            if (!this.dataToRender) {\r\n                console.log(\" maybe adding data for first time  \");\r\n\r\n            }\r\n            this.appendDataSource(liveData);\r\n        }\r\n    }\r\n\r\n    drawCircle(centery, centerx, color, radius, ctx) {\r\n        ctx.fillStyle = color;\r\n        ctx.beginPath();\r\n        ctx.arc(centerx, centery, radius, 0, 2 * Math.PI);\r\n        ctx.stroke();\r\n        ctx.fill();\r\n    }\r\n\r\n    //draws an arrow, up or down, for now height and width is fixed inside the function.\r\n    // point x and point y is the coordinate of the pointy part of arrow.\r\n    drawArrow(upArrow, pointX, pointY, ctx, color) {\r\n\r\n        let arrowHalfWidth = 12;\r\n        let arrowHeight = 12;\r\n        let bodyHeight = 12;\r\n        let bodyHalfWidth = 6;\r\n\r\n        ctx.fillStyle = color;\r\n        //ctx.translate(0.5, 0);\r\n        ctx.beginPath();\r\n\r\n        let strokeWidthOffset = 2; //stroking will increase the width by linewidth px, i.e 2 atm\r\n        if (upArrow) {\r\n            ctx.moveTo(pointX, pointY);\r\n            ctx.lineTo(pointX + arrowHalfWidth, pointY + arrowHeight);\r\n            ctx.lineTo(pointX + bodyHalfWidth, pointY + arrowHeight);\r\n            ctx.lineTo(pointX + bodyHalfWidth, pointY + arrowHeight + bodyHeight);\r\n            ctx.lineTo(pointX - bodyHalfWidth, pointY + arrowHeight + bodyHeight);\r\n            ctx.lineTo(pointX - bodyHalfWidth, pointY + arrowHeight);\r\n            ctx.lineTo(pointX - arrowHalfWidth, pointY + arrowHeight);\r\n            ctx.lineTo(pointX, pointY);\r\n        }\r\n        else {\r\n            ctx.moveTo(pointX, pointY);\r\n            ctx.lineTo(pointX - arrowHalfWidth, pointY - arrowHeight); //..\r\n            ctx.lineTo(pointX - bodyHalfWidth, pointY - arrowHeight);//..\r\n            ctx.lineTo(pointX - bodyHalfWidth, pointY - arrowHeight - bodyHeight);//..\r\n            ctx.lineTo(pointX + bodyHalfWidth, pointY - arrowHeight - bodyHeight);//..\r\n            ctx.lineTo(pointX + bodyHalfWidth, pointY - arrowHeight);//..\r\n            ctx.lineTo(pointX + arrowHalfWidth, pointY - arrowHeight);//..\r\n            ctx.lineTo(pointX, pointY);\r\n        }\r\n\r\n        ctx.fill();\r\n        ctx.stroke();\r\n    }\r\n\r\n    parseOLHC(item) {\r\n        if (!item) {\r\n            return;\r\n        }\r\n\r\n        item.high = parseFloat(item.high);\r\n        item.low = parseFloat(item.low);\r\n\r\n        if (item.lastPrice) {\r\n            item.close = parseFloat(item.lastPrice);\r\n        }\r\n\r\n        if (item.close) {\r\n            item.close = parseFloat(item.close);\r\n        }\r\n\r\n        item.open = parseFloat(item.open);\r\n        item.volume = parseFloat(item.volume);\r\n        return item;\r\n    }\r\n\r\n    drawHorizontalLine(ctx, y, x2, x1) {\r\n        ctx.translate(0, 0.5);\r\n        ctx.beginPath();\r\n        ctx.moveTo(x2, y);\r\n        ctx.lineTo(x1, y);\r\n        ctx.stroke();\r\n        ctx.translate(0, -0.5);\r\n    }\r\n\r\n    drawVerticalLine(ctx, x, y2, y1) {\r\n        ctx.translate(0.5, 0);\r\n        ctx.beginPath();\r\n        ctx.moveTo(x, y1);\r\n        ctx.lineTo(x, y2);\r\n        ctx.stroke();\r\n        ctx.translate(-0.5, 0);\r\n    }\r\n\r\n    drawRectangle(x1, y1, width, height, ctx) {\r\n        ctx.beginPath();\r\n        ctx.fillRect(x1, y1, width, height);\r\n\r\n        ctx.strokeRect(x1, y1, width, height);\r\n        ctx.stroke();\r\n    }\r\n\r\n    calculateMetricsFromCandlestick(priceInfo, positionInfo) {\r\n\r\n        if (!priceInfo) {\r\n            debugger;\r\n        }\r\n\r\n        var candleDrawData = {};\r\n        candleDrawData.wicktopy = this.getYPointFromPriceUnsafe(priceInfo.high);\r\n        candleDrawData.wickbottomy = this.getYPointFromPriceUnsafe(priceInfo.low);\r\n\r\n        //var localHalfBarSize = Math.ceil((positionInfo.width - 1) / 3); //positionInfo.width is total with including gap\r\n        var localHalfBarSize = this.renderingOptions.halfBarWidth;\r\n\r\n        candleDrawData.width = (localHalfBarSize * 2) + 1; //bar width without gap\r\n        var localGapSize = positionInfo.width - candleDrawData.width;\r\n        candleDrawData.bodysx = positionInfo.position;\r\n        candleDrawData.wickx = candleDrawData.bodysx + localHalfBarSize;\r\n\r\n        //candleDrawData.bodysx = positionInfo.position;\r\n        //candleDrawData.width = positionInfo.width - this.renderingOptions.visibleRange.gapSize;\r\n        //candleDrawData.wickx = positionInfo.position + this.renderingOptions.visibleRange.halfBarSize;\r\n        if (priceInfo.open < priceInfo.close) {\r\n            //green\r\n            candleDrawData.bodytopy = this.getYPointFromPriceUnsafe(priceInfo.close);\r\n            candleDrawData.bodybtmy = this.getYPointFromPriceUnsafe(priceInfo.open);\r\n            candleDrawData.color = priceInfo.otherInfo.upColor ? priceInfo.otherInfo.upColor : this.renderingOptions.candleColor1;\r\n        }\r\n        else {\r\n            candleDrawData.bodytopy = this.getYPointFromPriceUnsafe(priceInfo.open);\r\n            candleDrawData.bodybtmy = this.getYPointFromPriceUnsafe(priceInfo.close);\r\n            candleDrawData.color = priceInfo.otherInfo.downColor ? priceInfo.otherInfo.downColor : this.renderingOptions.candleColor2;\r\n        }\r\n        return candleDrawData;\r\n    }\r\n\r\n    eraseCandlestick(date) {\r\n        //find out the position of the date\r\n        let _positionInfo = {};\r\n\r\n        if (date < this.renderingOptions.lowDate || date > this.renderingOptions.highDate) {\r\n            return;\r\n        }\r\n\r\n        //find the distance from low\r\n        _positionInfo.position = ((date - this.renderingOptions.lowDate) / this.dataToRender.intervalMS) * this.renderingOptions.barWidth\r\n            - this.renderingOptions.lowHiddenPixels + this.renderingOptions.lowOffsetPixels;\r\n        _positionInfo.width = this.renderingOptions.barWidth;\r\n\r\n        this.canvas.cv1.getContext('2d').clearRect(_positionInfo.position, 0, _positionInfo.width, this.canvas.cv1.height);\r\n        return _positionInfo;\r\n    }\r\n\r\n    updateCandlestick(newTradeData) {\r\n        //get other properties first.\r\n        var posinfo = this.eraseCandlestick(newTradeData.time);\r\n\r\n        if (posinfo) {\r\n            this.drawACandleStick(newTradeData, posinfo);\r\n        }\r\n    }\r\n\r\n    getYPointFromPriceUnsafe(price) {\r\n        var pricePerPx = (this.renderingOptions.YHigh - this.renderingOptions.Ylow) / (this.canvas.cv1.height);\r\n        return (this.renderingOptions.YHigh - price) / pricePerPx;\r\n    }\r\n\r\n    setOrCreateRenderingOptions(options) {\r\n\r\n        if (!this.dataToRender) {\r\n            throw new Error(\"Cannot set or create rendering options without rendering data\");\r\n        }\r\n\r\n        if (options) {\r\n            this.renderingOptions = { ...this.renderingOptions, ...options };\r\n            return;\r\n        }\r\n\r\n        if (!options && !this.renderingOptions) {\r\n            this.renderingOptions = {};\r\n            Object.assign(this.renderingOptions, this.defaultRenderingOptions);\r\n            //this.renderingOptions = this.defaultRenderingOptions;\r\n\r\n            //calculate low and high\r\n            var maxtotalBars = Math.floor((this.canvas.cv1.width) / this.renderingOptions.barWidth);\r\n            var totalBars = this.dataToRender.candleData.size >= maxtotalBars ? maxtotalBars : this.dataToRender.candleData.size;\r\n            this.renderingOptions.lowOffsetPixels = 0;\r\n            this.renderingOptions.lowHiddenPixels = 0;\r\n            this.renderingOptions.highOffsetPixels = (this.canvas.cv1.width) - (totalBars * this.renderingOptions.barWidth);\r\n            this.renderingOptions.highDate = this.dataToRender.latestDate;\r\n            this.renderingOptions.lowDate = this.renderingOptions.highDate - ((totalBars - 1) * this.dataToRender.intervalMS);\r\n            this.renderingOptions.yPartDistance = Math.floor(180 / devicePixelRatio);\r\n            this.renderingOptions.panOffsetY = 0;\r\n            this.renderingOptions.ypartBreaking = { min: Math.floor(120 / devicePixelRatio), max: (200 / devicePixelRatio) };\r\n            this.renderingOptions.xpartBreaking = { min: Math.floor(0.12 * this.canvas.cv1.width), max: Math.floor(0.15 * this.canvas.cv1.width) };\r\n            this.renderingOptions.dateLinesMinGap = 100; //min 100 px, clamp to nearest candles midpoint so maybe lesser than 100px\r\n            this.renderingOptions.xPanDisplacement = 0;\r\n\r\n        }\r\n\r\n        if (this.newDataAdded) {\r\n            this.newDataAdded = false;\r\n\r\n            if (this.renderingOptions.highOffsetPixels > 0) {\r\n                if (this.renderingOptions.highDate < this.dataToRender.latestDate) {\r\n                    let diffpx = ((this.dataToRender.latestDate - this.renderingOptions.highDate) / this.dataToRender.intervalMS) * this.renderingOptions.barWidth;\r\n                    if (diffpx > this.renderingOptions.highOffsetPixels) {\r\n                        this.renderingOptions.highHiddenPixels = this.renderingOptions.barWidth - (this.renderingOptions.highOffsetPixels % this.renderingOptions.barWidth)\r\n                        this.renderingOptions.highOffsetPixels = 0;\r\n                        this.renderingOptions.highDate +=\r\n                            ((Math.ceil(this.renderingOptions.highOffsetPixels / this.renderingOptions.barWidth) * this.dataToRender.intervalMS))\r\n                    }\r\n                    else {\r\n                        this.renderingOptions.highDate = this.dataToRender.latestDate;\r\n                        this.renderingOptions.highOffsetPixels -= diffpx;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.renderingOptions.lowOffsetPixels > 0) {\r\n                if (this.renderingOptions.lowDate > this.dataToRender.oldestDate) {\r\n                    let diffpx = ((this.renderingOptions.lowDate - this.dataToRender.oldestDate) / this.dataToRender.intervalMS) * this.renderingOptions.barWidth;\r\n                    if (diffpx > this.renderingOptions.lowOffsetPixels) {\r\n                        this.renderingOptions.lowHiddenPixels = this.renderingOptions.lowOffsetPixels % this.renderingOptions.barWidth;\r\n                        this.renderingOptions.lowOffsetPixels = 0;\r\n                        this.renderingOptions.lowDate = this.dataToRender.oldestDate +\r\n                            ((Math.ceil(this.renderingOptions.lowOffsetPixels / this.renderingOptions.barWidth) * this.dataToRender.intervalMS))\r\n                    }\r\n                    else {\r\n                        this.renderingOptions.lowDate = this.dataToRender.oldestDate;\r\n                        this.renderingOptions.lowOffsetPixels -= diffpx;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    adjustYboundsInitially() {\r\n\r\n        if (!this.renderingOptions) {\r\n            this.setOrCreateRenderingOptions();\r\n        }\r\n\r\n        //use the activechartdata and xpointers.\r\n        var pointerDate = this.renderingOptions.lowDate;\r\n\r\n        var highesty = 0;\r\n        var lowesty = Number.MAX_SAFE_INTEGER;\r\n\r\n        while (pointerDate <= this.renderingOptions.highDate) {\r\n\r\n            var candledata = this.dataToRender.candleData.get(pointerDate);\r\n            if (!candledata) {\r\n                console.log(\"Non existent date, unable to adjust bounds.\");\r\n                console.log(pointerDate);\r\n                break;\r\n            }\r\n\r\n            console.log(\"adjusting\");\r\n            if (highesty < candledata.high) {\r\n                highesty = candledata.high + (0.03 * candledata.high);\r\n                console.log(\"High set to: \" + highesty.toString());\r\n            }\r\n\r\n            if (lowesty > candledata.low) {\r\n                lowesty = candledata.low - (0.03 * candledata.low);\r\n                console.log(\"Low set to: \" + lowesty.toString());\r\n            }\r\n            if (this.dataToRender.intervalMS == 0) {\r\n                break;\r\n            }\r\n            pointerDate += this.dataToRender.intervalMS;\r\n        }\r\n\r\n        this.renderingOptions.Ylow = lowesty;\r\n        this.renderingOptions.YHigh = highesty;\r\n    }\r\n\r\n    //mouse going left.\r\n    goLeft(diff) {\r\n\r\n        this.isCanvasDragging = true;\r\n        //clamp\r\n        var ThirdLatestBar = this.dataToRender.latestDate - (this.dataToRender.intervalMS * 2);\r\n        var distFromLowToSecondLatest = ((((ThirdLatestBar - this.renderingOptions.lowDate) / this.dataToRender.intervalMS) + 1)\r\n            * this.renderingOptions.barWidth) - this.renderingOptions.lowHiddenPixels + this.renderingOptions.lowOffsetPixels;\r\n\r\n        diff = diff > distFromLowToSecondLatest ? distFromLowToSecondLatest : diff;\r\n\r\n        if (diff <= 0) {\r\n            return false;\r\n        }\r\n\r\n        this.renderingOptions.xPanDisplacement -= diff;\r\n\r\n        //adjust lowOffsetPx\r\n        this.renderingOptions.lowOffsetPixels -= diff;\r\n        if (this.renderingOptions.lowOffsetPixels < 0) {\r\n            diff = Math.abs(this.renderingOptions.lowOffsetPixels);\r\n            this.renderingOptions.lowOffsetPixels = 0;\r\n        }\r\n        else {\r\n            diff = 0;\r\n        }\r\n\r\n        var internalCWidth = (this.canvas.cv1.width);\r\n\r\n        var times = Math.floor(diff / this.renderingOptions.barWidth);\r\n        var rem = Math.floor(diff % this.renderingOptions.barWidth);\r\n\r\n        if (rem + this.renderingOptions.lowHiddenPixels > this.renderingOptions.barWidth) {\r\n            times += 1;\r\n            this.renderingOptions.lowHiddenPixels = rem - (this.renderingOptions.barWidth - this.renderingOptions.lowHiddenPixels);\r\n        }\r\n        else {\r\n            this.renderingOptions.lowHiddenPixels += rem;\r\n        }\r\n\r\n        this.renderingOptions.lowDate += (times * this.dataToRender.intervalMS);\r\n\r\n        var lowHighDiff = Math.floor((internalCWidth - this.renderingOptions.lowOffsetPixels) / this.renderingOptions.barWidth);\r\n        var remPxDiff = (internalCWidth - this.renderingOptions.lowOffsetPixels) % this.renderingOptions.barWidth;\r\n\r\n        if (this.renderingOptions.lowHiddenPixels + remPxDiff > this.renderingOptions.barWidth) {\r\n            lowHighDiff += 1;\r\n            this.renderingOptions.highHiddenPixels = (2 * this.renderingOptions.barWidth) - (this.renderingOptions.lowHiddenPixels + remPxDiff); //just calc no need.\r\n        }\r\n        else {\r\n            this.renderingOptions.highHiddenPixels = this.renderingOptions.barWidth - (this.renderingOptions.lowHiddenPixels + remPxDiff);\r\n\r\n        }\r\n\r\n        this.renderingOptions.highDate = this.renderingOptions.lowDate + (lowHighDiff * this.dataToRender.intervalMS);\r\n\r\n        if (this.renderingOptions.highDate > this.dataToRender.latestDate) {\r\n            this.renderingOptions.highDate = this.dataToRender.latestDate;\r\n            this.renderingOptions.highHiddenPixels = 0;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    //mouse going right\r\n    goRight(diff) {\r\n\r\n        this.isCanvasDragging = true;\r\n        //second oldest is the minimum possible high, clamp\r\n        var DistHighToSecondOldest = (((this.renderingOptions.highDate - this.dataToRender.oldestDate - this.dataToRender.intervalMS)\r\n            / this.dataToRender.intervalMS) * this.renderingOptions.barWidth) - this.renderingOptions.highHiddenPixels;\r\n        var tempHighOffsetPixels = this.canvas.cv1.width - (((((this.renderingOptions.highDate - this.renderingOptions.lowDate) / this.dataToRender.intervalMS) + 1)\r\n            * this.renderingOptions.barWidth) - this.renderingOptions.lowHiddenPixels - this.renderingOptions.highHiddenPixels + this.renderingOptions.lowOffsetPixels);\r\n\r\n        DistHighToSecondOldest += tempHighOffsetPixels;\r\n        diff = diff > DistHighToSecondOldest ? DistHighToSecondOldest : diff;\r\n\r\n        if (diff <= 0) {\r\n            return false;\r\n        }\r\n\r\n        this.renderingOptions.xPanDisplacement += diff;\r\n        //distance from low to oldest\r\n        var DistLowToOldest = (((this.renderingOptions.lowDate - this.dataToRender.oldestDate) / this.dataToRender.intervalMS) *\r\n            this.renderingOptions.barWidth) + this.renderingOptions.lowHiddenPixels;\r\n\r\n        if (this.renderingOptions.lowOffsetPixels > 0) {\r\n            this.renderingOptions.lowOffsetPixels += diff;\r\n        }\r\n        else {\r\n            if (diff >= DistLowToOldest) {\r\n                this.renderingOptions.lowDate = this.dataToRender.oldestDate;\r\n                this.renderingOptions.lowHiddenPixels = 0;\r\n                this.renderingOptions.lowOffsetPixels += (diff - DistLowToOldest);\r\n            }\r\n            else {\r\n                //calculate low \r\n                var times = Math.floor(diff / this.renderingOptions.barWidth);\r\n                var rem = diff % this.renderingOptions.barWidth;\r\n                if (this.renderingOptions.lowHiddenPixels < rem) {\r\n                    times += 1;\r\n                    this.renderingOptions.lowHiddenPixels = this.renderingOptions.barWidth - (rem - this.renderingOptions.lowHiddenPixels);\r\n                }\r\n                else {\r\n                    this.renderingOptions.lowHiddenPixels -= rem;\r\n                }\r\n\r\n                this.renderingOptions.lowDate -= (times * this.dataToRender.intervalMS);\r\n\r\n            }\r\n        }\r\n\r\n        //now calculate the new high.\r\n        var internalCWidth = (this.canvas.cv1.width);\r\n        var lowHighDiff = Math.floor((internalCWidth - this.renderingOptions.lowOffsetPixels) / this.renderingOptions.barWidth);\r\n        var remPxDiff = (internalCWidth - this.renderingOptions.lowOffsetPixels) % this.renderingOptions.barWidth;\r\n\r\n        if (this.renderingOptions.lowHiddenPixels + remPxDiff > this.renderingOptions.barWidth) {\r\n            lowHighDiff += 1;\r\n            this.renderingOptions.highHiddenPixels = (2 * this.renderingOptions.barWidth) - (this.renderingOptions.lowHiddenPixels + remPxDiff); //just calc no need.\r\n        }\r\n        else {\r\n            this.renderingOptions.highHiddenPixels = this.renderingOptions.barWidth - (this.renderingOptions.lowHiddenPixels + remPxDiff);\r\n        }\r\n\r\n        this.renderingOptions.highDate = this.renderingOptions.lowDate + (lowHighDiff * this.dataToRender.intervalMS);\r\n\r\n        if (this.renderingOptions.highDate > this.dataToRender.latestDate) {\r\n            this.renderingOptions.highDate = this.dataToRender.latestDate;\r\n            this.renderingOptions.highHiddenPixels = 0;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    goYpan(diffY) {\r\n        if (diffY != 0) {\r\n\r\n            //calculate new pixel ratio\r\n            var priceToPxRatio = (this.renderingOptions.YHigh - this.renderingOptions.Ylow) / this.canvas.cv1.height;\r\n            var offsetVal = Math.round((diffY * priceToPxRatio) * 1000) / 1000;\r\n            var newylow = this.renderingOptions.Ylow + offsetVal;\r\n            var newyhigh = this.renderingOptions.YHigh + offsetVal;\r\n\r\n            this.renderingOptions.panOffsetY += (offsetVal / priceToPxRatio);\r\n\r\n            this.renderingOptions.Ylow = newylow;\r\n            this.renderingOptions.YHigh = newyhigh;\r\n\r\n            if (Math.abs(this.renderingOptions.panOffsetY) >= this.renderingOptions.yPartDistance) {\r\n\r\n                if (this.renderingOptions.panOffsetY < 0) {\r\n                    this.renderingOptions.panOffsetY += this.renderingOptions.yPartDistance;\r\n                }\r\n                else {\r\n                    this.renderingOptions.panOffsetY -= this.renderingOptions.yPartDistance;\r\n                }\r\n                //this.renderingOptions.panOffsetY = 0;\r\n            }\r\n\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    goYZoom(diff) {\r\n        if (diff == 0) {\r\n            return false;\r\n        }\r\n        var diff = diff / this.renderingOptions.YZoomRate;\r\n        var rdiff = Math.round((diff) * 100) / 100;\r\n        var ih = this.backGroundCanvas.cv2.height;\r\n        var ldiff = rdiff * ((ih - 2 * this.renderingOptions.panOffsetY) / (ih + 2 * this.renderingOptions.panOffsetY));\r\n\r\n        //now this price needs to be maintained until next breaking\r\n        var pr1 = (this.renderingOptions.YHigh - this.renderingOptions.Ylow) / ih;\r\n        var yPriceDist = this.renderingOptions.yPartDistance * pr1;\r\n\r\n        if (diff > 0) {\r\n            //mouse went down\r\n            this.renderingOptions.Ylow -= ldiff * pr1;\r\n            this.renderingOptions.YHigh += rdiff * pr1;\r\n        }\r\n        else {\r\n\r\n            this.renderingOptions.Ylow -= ldiff * pr1;\r\n            this.renderingOptions.YHigh += rdiff * pr1;\r\n        }\r\n\r\n        //calculate ypartdistance based on new pixel ratio.\r\n        this.renderingOptions.yPartDistance = yPriceDist / ((this.renderingOptions.YHigh - this.renderingOptions.Ylow) / ih);\r\n\r\n        if (this.renderingOptions.yPartDistance < this.renderingOptions.ypartBreaking.min) {\r\n            //breaking into big\r\n            this.renderingOptions.yPartDistance = this.renderingOptions.ypartBreaking.max;\r\n            console.log(\"Breaking into big\");\r\n        }\r\n\r\n        if (this.renderingOptions.yPartDistance > this.renderingOptions.ypartBreaking.max) {\r\n            //breaking into small\r\n            this.renderingOptions.yPartDistance = this.renderingOptions.ypartBreaking.min;\r\n            console.log(\"Breaking into small\");\r\n        }\r\n        //console.log(\"Y, zooming\");\r\n        return true;\r\n    }\r\n\r\n    DrawBackgroundLines() {\r\n\r\n        //horizontal pricel lines\r\n        var midPointToDraw = Math.floor(this.canvas.cv2.height / 2);\r\n        var newOffsetPoint = midPointToDraw + this.renderingOptions.panOffsetY;\r\n        var ctx = this.backGroundCanvas.cv1.getContext('2d');\r\n        var ctx1 = this.backGroundCanvas.cv2.getContext('2d');\r\n        var ctx3 = this.backGroundCanvas.cv3.getContext('2d');\r\n\r\n        ctx.lineWidth = 1;\r\n        ctx.strokeStyle = \"rgb(212, 208, 207)\";\r\n        ctx1.font = '20px serif';\r\n\r\n        this.drawHorizontalLine(ctx, newOffsetPoint, this.backGroundCanvas.cv1.width, 0);\r\n        this.WriteInCanvas(ctx1, this.getPriceFromInternalPoint(newOffsetPoint).toFixed(6).toString(), newOffsetPoint);\r\n\r\n        while (newOffsetPoint > 0) {\r\n            this.drawHorizontalLine(ctx, newOffsetPoint, this.backGroundCanvas.cv1.width, 0);\r\n            this.WriteInCanvas(ctx1, this.getPriceFromInternalPoint(newOffsetPoint).toFixed(6).toString(), newOffsetPoint, 0);\r\n            newOffsetPoint -= this.renderingOptions.yPartDistance;\r\n        }\r\n\r\n        newOffsetPoint = midPointToDraw + this.renderingOptions.panOffsetY + this.renderingOptions.yPartDistance;\r\n        ctx3.font = '20px serif';\r\n        while (newOffsetPoint < this.canvas.cv1.height) {\r\n            this.drawHorizontalLine(ctx, newOffsetPoint, this.backGroundCanvas.cv1.width, 0);\r\n            this.WriteInCanvas(ctx1, this.getPriceFromInternalPoint(newOffsetPoint).toFixed(6).toString(), newOffsetPoint, 0);\r\n            newOffsetPoint += this.renderingOptions.yPartDistance;\r\n        }\r\n\r\n        //vertical date lines.\r\n\r\n        //calculate nearest number of bars for minimum distance.\r\n        var barsPerLine = Math.floor(this.canvas.cv1.width / this.renderingOptions.dateLinesMinGap);\r\n        var distWidth = barsPerLine * this.renderingOptions.barWidth;\r\n        this.renderingOptions.xPanDisplacement = this.renderingOptions.xPanDisplacement % distWidth;\r\n        var xpos = this.renderingOptions.gapSize + this.renderingOptions.halfBarWidth + this.renderingOptions.xPanDisplacement;\r\n        while (barsPerLine > 0) {\r\n            this.drawVerticalLine(ctx, xpos, this.backGroundCanvas.cv1.height, 0);\r\n            var writeDate = new Date(this.getCurrentHoveringCandleDate(xpos));\r\n            var timePart = writeDate.toLocaleTimeString();\r\n            var datePart = writeDate.toLocaleDateString();\r\n\r\n            this.WriteInCanvas(ctx3, timePart, 20, xpos - 30);\r\n            this.WriteInCanvas(ctx3, datePart, 40, xpos - 30)\r\n            barsPerLine -= 1;\r\n            xpos += distWidth;\r\n        }\r\n    }\r\n\r\n    getPriceFromInternalPoint(ypoint) {\r\n        var pxRatio = (this.renderingOptions.YHigh - this.renderingOptions.Ylow) / this.canvas.cv1.height;\r\n        return (this.renderingOptions.YHigh - (pxRatio * ypoint));\r\n    }\r\n\r\n    WriteInCanvas(ctx, txt, y, x) {\r\n        ctx.fillText(txt, x, y);\r\n    }\r\n\r\n    clearCandles() {\r\n        this.canvas.cv1.getContext(\"2d\").clearRect(0, 0, (this.canvas.cv1.width), (this.canvas.cv1.height));\r\n        this.backGroundCanvas.cv1.getContext(\"2d\").clearRect(0, 0, (this.backGroundCanvas.cv1.width), (this.backGroundCanvas.cv1.height));\r\n        this.backGroundCanvas.cv2.getContext(\"2d\").clearRect(0, 0, (this.backGroundCanvas.cv2.width), (this.backGroundCanvas.cv2.height));\r\n        this.backGroundCanvas.cv3.getContext(\"2d\").clearRect(0, 0, (this.backGroundCanvas.cv3.width), (this.backGroundCanvas.cv3.height));\r\n        //also clear rect of cv2 --- todo later\r\n\r\n        this.frontCanvas.cv1.getContext('2d').clearRect(0, 0, this.frontCanvas.cv1.width, this.frontCanvas.cv1.height);\r\n        this.frontCanvas.cv2.getContext('2d').clearRect(0, 0, this.frontCanvas.cv2.width, this.frontCanvas.cv2.height);\r\n        this.frontCanvas.cv3.getContext('2d').clearRect(0, 0, this.frontCanvas.cv3.width, this.frontCanvas.cv3.height);\r\n    }\r\n\r\n    getCurrentHoveringCandleDate(xpos) {\r\n        xpos += (this.renderingOptions.lowHiddenPixels - this.renderingOptions.lowOffsetPixels);\r\n        var addBars = Math.floor(xpos / this.renderingOptions.barWidth);\r\n\r\n        return this.renderingOptions.lowDate + (addBars * this.dataToRender.intervalMS);\r\n    }\r\n\r\n    getHoveringCandleMidPoint(xpos) {\r\n        let bigXpos = xpos + this.renderingOptions.lowHiddenPixels - this.renderingOptions.lowOffsetPixels;\r\n        let fullXpos = Math.ceil(bigXpos / this.renderingOptions.barWidth) * this.renderingOptions.barWidth;\r\n\r\n        let candleMidPoint = fullXpos - this.renderingOptions.lowHiddenPixels + this.renderingOptions.lowOffsetPixels - this.renderingOptions.halfBarWidth - this.renderingOptions.gapSize;\r\n        return candleMidPoint;\r\n    }\r\n\r\n    writeHoveringCandleDetails(date) {\r\n        if (!this.dataToRender || !this.renderingOptions || !date) {\r\n            return;\r\n        }\r\n\r\n        if (date < this.renderingOptions.lowDate || date > this.renderingOptions.highDate) {\r\n            return;\r\n        }\r\n\r\n        let candleDetails = this.dataToRender.candleData.get(date);\r\n        let ctx1 = this.frontCanvas.cv1.getContext(\"2d\");\r\n\r\n        if (!candleDetails) {\r\n            debugger;\r\n        }\r\n\r\n        ctx1.font = '30px serif';\r\n        let txtToWrite = \"O: \" + candleDetails.open.toFixed(6).toString() + \" H: \" + candleDetails.high.toFixed(6).toString() +\r\n            \" L: \" + candleDetails.low.toFixed(6).toString() + \" C: \" + candleDetails.close.toFixed(6).toString();\r\n\r\n        //for now put the coordinates here\r\n        let x1 = 20;\r\n        let y1 = 20;\r\n        let width = ctx1.measureText(txtToWrite).width + 40;\r\n        let height = 40;\r\n\r\n\r\n        ctx1.globalAlpha = 0.7;\r\n        ctx1.fillStyle = \"white\";\r\n        ctx1.setLineDash([]);\r\n        //create a white rectangle above in the front canvas\r\n        this.drawRectangle(x1, y1, width, height, ctx1);\r\n\r\n        ctx1.globalAlpha = 1;\r\n\r\n        //now draw texts\r\n        let txtColor = \"green\";\r\n        if (candleDetails.close < candleDetails.open) {\r\n            //red\r\n            txtColor = \"red\";\r\n        }\r\n\r\n        ctx1.fillStyle = candleDetails.otherInfo.candleStickBodyColor ? _priceInfo.otherInfo.candleStickBodyColor : txtColor;\r\n        this.WriteInCanvas(ctx1, txtToWrite, y1 + 30, x1 + 10);\r\n\r\n\r\n    }\r\n\r\n    onMouseHover(e) {\r\n\r\n        if (this.isCanvasDragging || !this.renderingOptions || !this.dataToRender) {\r\n            return;\r\n        }\r\n        //get the x and y position of mouse.\r\n        if (Date.now() - this.lastMouseHoverDate < this.mouseHoverFrameRate) {\r\n            return;\r\n        }\r\n\r\n        this.frontCanvas.cv1.getContext('2d').clearRect(0, 0, this.frontCanvas.cv1.width, this.frontCanvas.cv1.height);\r\n        this.frontCanvas.cv2.getContext('2d').clearRect(0, 0, this.frontCanvas.cv2.width, this.frontCanvas.cv2.height);\r\n        this.frontCanvas.cv3.getContext('2d').clearRect(0, 0, this.frontCanvas.cv3.width, this.frontCanvas.cv3.height);\r\n\r\n        var rect = e.target.getBoundingClientRect();\r\n        var xpos = (e.clientX - rect.left) * devicePixelRatio; //x position within the element.\r\n        var ypos = (e.clientY - rect.top) * devicePixelRatio;  //y position within the element.\r\n        this.lastHoverPosition = e;\r\n\r\n        //get date from x pos\r\n        var hoveringDate = this.getCurrentHoveringCandleDate(xpos);\r\n\r\n        if (hoveringDate < this.renderingOptions.lowDate || hoveringDate > this.renderingOptions.highDate) {\r\n            return;\r\n        }\r\n\r\n        this.writeHoveringCandleDetails(hoveringDate);\r\n\r\n        this.renderingOptions.hoveringCandleDate = hoveringDate;\r\n\r\n        //get date data\r\n        var hoveringCandleMidpoint = this.getHoveringCandleMidPoint(xpos);\r\n        //display that date in tooltip --later\r\n\r\n\r\n        //also draw a shade in candlestick canvas as candlestick background and cursor cross\r\n\r\n        var ctx1 = this.frontCanvas.cv1.getContext(\"2d\");\r\n        var ctx2 = this.frontCanvas.cv2.getContext(\"2d\");\r\n        var ctx3 = this.frontCanvas.cv3.getContext(\"2d\");\r\n\r\n        ctx1.setLineDash([10, 10]);\r\n        this.drawHorizontalLine(ctx1, ypos, 0, this.frontCanvas.cv1.width);\r\n        this.drawVerticalLine(ctx1, hoveringCandleMidpoint, 0, this.frontCanvas.cv1.height);\r\n\r\n        //now draw date as well.\r\n        var writeDate = new Date(hoveringDate);\r\n        var timePart = writeDate.toLocaleTimeString();\r\n        var datePart = writeDate.toLocaleDateString();\r\n\r\n        //----------------------------------\r\n\r\n        ctx3.fillStyle = \"orange\";\r\n        ctx3.fillRect(hoveringCandleMidpoint - 60, 0, 130, 50);\r\n        //ctx3.strokeRect(hoveringCandleMidpoint - 30, 0, 100, 40);\r\n        ctx3.strokeStyle = \"rgb(212, 208, 207)\";\r\n        ctx3.font = '20px serif';\r\n        ctx3.fillStyle = \"black\";\r\n        this.WriteInCanvas(ctx3, timePart, 20, hoveringCandleMidpoint - 45);\r\n        this.WriteInCanvas(ctx3, datePart, 40, hoveringCandleMidpoint - 45)\r\n\r\n        //-------------------\r\n        var priceInY = this.renderingOptions.YHigh - (ypos * (this.renderingOptions.YHigh - this.renderingOptions.Ylow) / this.frontCanvas.cv2.height);\r\n        ctx2.fillStyle = \"orange\";\r\n        ctx2.fillRect(0, ypos - 20, this.frontCanvas.cv2.width, 40);\r\n        //ctx3.strokeRect(0, ypos - 10, this.frontCanvas.cv2.width, 20);\r\n        ctx2.strokeStyle = \"rgb(212, 208, 207)\";\r\n        ctx2.font = '20px serif';\r\n        ctx2.fillStyle = \"black\";\r\n        this.WriteInCanvas(ctx2, priceInY.toFixed(6).toString(), ypos + 10, 0);\r\n        this.lastMouseHoverDate = Date.now();\r\n    }\r\n\r\n    drawTickerPriceLine(price) {\r\n        //get contect\r\n        var ctx1 = this.f1Canvas.cv1.getContext(\"2d\");\r\n        ctx1.clearRect(0, 0, this.f1Canvas.cv1.width, this.f1Canvas.cv1.height);\r\n        let ypos = this.getYPointFromPriceUnsafe(price);\r\n        ctx1.setLineDash([10, 10]);\r\n        this.drawHorizontalLine(ctx1, ypos, 0, this.f1Canvas.cv1.width);\r\n    }\r\n\r\n}\n\n//# sourceURL=webpack://easyChart/./js/candleRenderer.js?");

/***/ }),

/***/ "./js/dataRenderer.js":
/*!****************************!*\
  !*** ./js/dataRenderer.js ***!
  \****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ dataRenderer)\n/* harmony export */ });\n/* harmony import */ var _candleRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./candleRenderer.js */ \"./js/candleRenderer.js\");\n/* harmony import */ var _layeredCanvas_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layeredCanvas.js */ \"./js/layeredCanvas.js\");\n/* harmony import */ var _onMouesDrag_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./onMouesDrag.js */ \"./js/onMouesDrag.js\");\n\r\n\r\n\r\n\r\nclass dataRenderer {\r\n    constructor(container, settings) {\r\n\r\n        this.mainContainer = container;\r\n        this.layredCanvas;\r\n        //data renderer will expose function that can be called from analyzer to display certain data.\r\n        this.candlestickLayerID = 10;\r\n        this.backgroundLayerID = 5;\r\n        this.indicatorLayerID = 15;\r\n\r\n        this.canvas1HeightCSS = settings.height;\r\n        this.canvas1WidthCSS = settings.width;\r\n        this.canvas2HeightCSS = this.canvas1HeightCSS;\r\n        this.canvas2WidthCSS = 80;///todo \r\n\r\n        this.renderers = new Map();\r\n\r\n        this.generateLayredCanvas();\r\n\r\n        (0,_onMouesDrag_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"cvb1Container\", {\r\n            cb: this.onPanning,\r\n            parent: this,\r\n        });\r\n\r\n        (0,_onMouesDrag_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(\"cvb2Container\", {\r\n            cb: this.OnYZooming,\r\n            parent: this,\r\n        });\r\n    }\r\n\r\n    addRenderer(typeID) {\r\n        let newRenderer;\r\n        if (typeID == \"candle\") {\r\n            newRenderer = new _candleRenderer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this);\r\n        }\r\n        this.renderers.set(typeID, newRenderer);\r\n        return newRenderer;\r\n    }\r\n\r\n    getRenderer(typeID) {\r\n        return this.renderers.get(typeID);\r\n    }\r\n\r\n\r\n    createBackgroundLayer() {\r\n        if (!this.layredCanvas) {\r\n            this.generateLayredCanvas();\r\n        }\r\n        this.layredCanvas.addLayer(this.backgroundLayerID);\r\n    }\r\n\r\n    createCandlestickLayer() {\r\n        if (!this.candlestickLayerID) {\r\n            this.generateLayredCanvas();\r\n        }\r\n\r\n        var layeerObj = this.layredCanvas.addLayer(this.candlestickLayerID);\r\n\r\n        //also add the renderer\r\n        if (!this.renderers.get(\"candle\")) {\r\n            var candlestickRenderer = new _candleRenderer_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this);\r\n            this.renderers.set(\"candle\", candlestickRenderer);\r\n        }\r\n    }\r\n\r\n    createIndicatorLayer() {\r\n        if (!this.indicatorLayerID) {\r\n            generateLayredCanvas();\r\n        }\r\n        this.layredCanvas.addLayer(this.indicatorLayerID);\r\n    }\r\n\r\n    generateLayredCanvas() {\r\n        if (!(this.mainContainer instanceof HTMLDivElement)) {\r\n            throw new Error(\"Unable to generate layered canvas, Container for data renderer is not a html divElement\");\r\n        }\r\n\r\n        this.layredCanvas = new _layeredCanvas_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](this.mainContainer, this.canvas1WidthCSS, this.canvas1HeightCSS);\r\n        return this.layredCanvas;\r\n    }\r\n\r\n    getPairData(pairObj) {\r\n        if (!this.dataManager) {\r\n            return;\r\n        }\r\n        //load the exchange first.\r\n        var conn = this.dataManager.tradingExchange(pairObj.exchange);\r\n\r\n        if (!conn) {\r\n            return;\r\n        }\r\n\r\n        var pairdata = conn.pairData.get(pairObj);\r\n\r\n        return pairdata;\r\n    }\r\n\r\n    loadCandlestick(dataPairValue, _renderingOptions) {\r\n\r\n        //process it and render it.\r\n        //data {//candleMap, oldestDate, latestTicker, interval}\r\n\r\n        var candleRenderer = this.renderers.get(\"candle\");\r\n        candleRenderer.drawCandlesticks(dataPairValue, _renderingOptions);\r\n    }\r\n\r\n    onPanning(detail, parent) {\r\n\r\n        //calculate the change.\r\n        var rawDiffX = detail.screenX - detail.prevMouseDetail.x;\r\n        var rawDiffY = detail.screenY - detail.prevMouseDetail.y;\r\n\r\n\r\n        //distance from second latest is important.\r\n        //after calculating diff.\r\n\r\n        var diff = Math.abs(rawDiffX);\r\n        var cr = parent.renderers.get(\"candle\");\r\n        var isXpan = false;\r\n        var isYpan = false;\r\n\r\n        //x pan\r\n        if (rawDiffX > 0) {\r\n            isXpan = cr.goRight(diff);\r\n        }\r\n        else {\r\n            isXpan = cr.goLeft(diff);\r\n        }\r\n\r\n        // y pan\r\n        if (rawDiffY != 0) {\r\n            isYpan = cr.goYpan(rawDiffY);\r\n        }\r\n\r\n        if (isYpan || isXpan) {\r\n            cr.refresh();\r\n        }\r\n\r\n    }\r\n\r\n    OnYZooming(detail, parent) {\r\n        //var rawDiffX = detail.screenX - detail.prevMouseDetail.x;\r\n        var rawDiffY = detail.screenY - detail.prevMouseDetail.y;\r\n        if (rawDiffY != 0) {\r\n            var cr = parent.renderers.get(\"candle\");\r\n            cr.goYZoom(rawDiffY);\r\n            cr.refresh();\r\n        }\r\n    }\r\n\r\n    OnTickerData(candleObject) {\r\n        //candle object is the actual ticker data.\r\n        var cv = this.renderers.get(\"candle\");\r\n        cv.updateCandlestick(candleObject);\r\n    }\r\n\r\n}\r\n\r\n\n\n//# sourceURL=webpack://easyChart/./js/dataRenderer.js?");

/***/ }),

/***/ "./js/layeredCanvas.js":
/*!*****************************!*\
  !*** ./js/layeredCanvas.js ***!
  \*****************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ layeredCanvas)\n/* harmony export */ });\nclass layeredCanvas {\r\n\r\n\tconstructor(parent, _width, _height) {\r\n\t\tthis.coll = new Map();\r\n\t\tthis.Container = document.createElement(\"div\");\r\n\t\tthis.Container.setAttribute(\"id\", \"ChartContainer\");\r\n\r\n\t\tthis.Container.style.display = \"inline-block\";\r\n\t\tthis.extraBorderAndMarginPx = 3;\r\n\t\tthis.cssWidth = _width;\r\n\t\tthis.cssHeight = _height;\r\n\r\n\t\tthis.minYaxixWidth = 80;\r\n\t\tthis.minXaxisHeight = 40;\r\n\r\n\t\tthis.Container.style.width = String(this.cssWidth) + \"px\";\r\n\t\tthis.Container.style.height = String(this.cssHeight) + \"px\";\r\n\r\n\t\tparent.appendChild(this.Container);\r\n\t\tthis.AddDivsForEvent();\r\n\r\n\t\tthis.totalLayers = 0;\r\n\t}\r\n\r\n\tAddDivsForEvent() {\r\n\t\tvar cvb1 = document.createElement(\"div\");\r\n\t\tcvb1.setAttribute(\"id\", \"cvb1Container\");\r\n\r\n\t\tcvb1.style.width = String(this.cssWidth - this.minYaxixWidth - this.extraBorderAndMarginPx) + \"px\";\r\n\t\tcvb1.style.height = String(this.cssHeight - this.minXaxisHeight - this.extraBorderAndMarginPx) + \"px\";\r\n\t\tcvb1.style.display = \"inline-block\";\r\n\t\tcvb1.style.marginRight = \"2px\"\r\n\t\tcvb1.style.borderBottom = \"1px solid black\";\r\n\r\n\t\t//\r\n\t\tvar cvb2 = document.createElement(\"div\");\r\n\t\tcvb2.setAttribute(\"id\", \"cvb2Container\");\r\n\t\tcvb2.style.cursor = \"ns-resize\";\r\n\r\n\t\tcvb2.style.width = String(this.minYaxixWidth) + \"px\";\r\n\t\tcvb2.style.height = String(this.cssHeight - this.minXaxisHeight - this.extraBorderAndMarginPx) + \"px\";\r\n\t\tcvb2.style.display = \"inline-block\";\r\n\t\tcvb2.style.borderLeft = \"1px solid black\";\r\n\t\tcvb2.style.borderBottom = \"1px solid black\";\r\n\t\t//\r\n\r\n\t\tvar cvb3 = document.createElement(\"div\");\r\n\t\tcvb3.setAttribute(\"id\", \"cvb3Container\");\r\n\t\tcvb3.style.cursor = \"ew-resize\";\r\n\r\n\t\tcvb3.style.width = cvb1.style.width;\r\n\t\tcvb3.style.height = String(this.minXaxisHeight) + \"px\";\r\n\t\tcvb3.style.display = \"inline-block\";\r\n\t\tcvb3.style.marginTop = \"2px\";\r\n\r\n\t\tthis.cvb1 = cvb1;\r\n\t\tthis.cvb2 = cvb2;\r\n\t\tthis.cvb3 = cvb3;\r\n\r\n\t\tthis.Container.appendChild(cvb1);\r\n\t\tthis.Container.appendChild(cvb2);\r\n\t\tthis.Container.appendChild(cvb3);\r\n\t}\r\n\r\n\tchangeSize(newWidth, newHeight) {\r\n\t\tthis.cssWidth = newWidth;\r\n\t\tthis.cssHeight = newHeight;\r\n\r\n\t\tfor (element of coll) {\r\n\t\t\telement.cv1.value.width = String(this.cssWidth) + \"px\";\r\n\t\t\telement.cv1.value.height = String(this.cssHeight) + \"px\";\r\n\t\t\telement.cv2.value.height = String(this.cssHeight) + \"px\";\r\n\t\t}\r\n\t}\r\n\r\n\taddLayer(id, addXaxis, addYaxix) {\r\n\t\tif (this.coll.has(id)) {\r\n\t\t\tconsole.log('Layer with that ID already exists');\r\n\t\t\treturn this.getLayer(id);\r\n\t\t}\r\n\t\telse {\r\n\r\n\t\t\tvar canvas1 = document.createElement(\"canvas\");\r\n\t\t\tthis.cvb1.appendChild(canvas1);\r\n\r\n\t\t\tcanvas1.style.position = \"absolute\";\r\n\t\t\tcanvas1.style.zIndex = id;\r\n\t\t\tcanvas1.style.height = String(this.cssHeight - this.minXaxisHeight - this.extraBorderAndMarginPx) + \"px\";\r\n\t\t\tcanvas1.style.width = String((this.cssWidth - this.minYaxixWidth - this.extraBorderAndMarginPx)) + \"px\";\r\n\r\n\t\t\tcanvas1.height = Math.floor((this.cssHeight - this.minXaxisHeight - this.extraBorderAndMarginPx) * devicePixelRatio);\r\n\t\t\tcanvas1.width = Math.floor((this.cssWidth - this.minYaxixWidth) * devicePixelRatio);\r\n\r\n\t\t\tvar canvas2;\r\n\t\t\tvar canvas3;\r\n\r\n\t\t\tif (addYaxix) {\r\n\t\t\t\tcanvas2 = document.createElement(\"canvas\"); //yaxis\r\n\t\t\t\tthis.cvb2.appendChild(canvas2);\r\n\t\t\t\tcanvas2.style.position = \"absolute\";\r\n\t\t\t\tcanvas2.style.zIndex = id;\r\n\r\n\t\t\t\tcanvas2.height = Math.floor((this.cssHeight - this.minXaxisHeight - this.extraBorderAndMarginPx) * devicePixelRatio);\r\n\t\t\t\tcanvas2.width = Math.floor(this.minYaxixWidth * devicePixelRatio);\r\n\r\n\t\t\t\tcanvas2.style.height = String(this.cssHeight - this.minXaxisHeight - this.extraBorderAndMarginPx) + \"px\";\r\n\t\t\t\tcanvas2.style.width = String(this.minYaxixWidth) + \"px\";\r\n\t\t\t}\r\n\r\n\t\t\tif (addXaxis) {\r\n\t\t\t\tcanvas3 = document.createElement(\"canvas\"); //xaxis\r\n\t\t\t\tthis.cvb3.appendChild(canvas3);\r\n\t\t\t\tcanvas3.style.position = \"absolute\";\r\n\t\t\t\tcanvas3.style.zIndex = id;\r\n\t\t\t\tcanvas3.style.height = String(this.minXaxisHeight) + \"px\";\r\n\t\t\t\tcanvas3.style.width = canvas1.style.width;\r\n\r\n\t\t\t\tcanvas3.height = Math.floor(this.minXaxisHeight * devicePixelRatio);\r\n\t\t\t\tcanvas3.width = canvas1.width;\r\n\t\t\t}\r\n\r\n\t\t\tthis.coll.set(id, {\r\n\t\t\t\tcv1: canvas1,\r\n\t\t\t\tcv2: canvas2,\r\n\t\t\t\tcv3: canvas3,\r\n\t\t\t});\r\n\r\n\t\t\tthis.totalLayers += 1;\r\n\r\n\t\t\tconsole.log(\"Layer added of id: \" + id);\r\n\t\t\treturn this.getLayer(id);\r\n\t\t}\r\n\t}\r\n\r\n\tchangeID() {\r\n\r\n\t}\r\n\r\n\tremoveLayer(id) {\r\n\t\tif (coll.has(id)) {\r\n\r\n\t\t\tthis.Container.removeChild(coll.get(id));\r\n\t\t\tthis.coll.delete(id);\r\n\r\n\t\t\tthis.totalLayers -= 1;\r\n\t\t\tconsole.log(\"Layer has been removed\");\r\n\t\t}\r\n\t}\r\n\r\n\tgetLayer(id) {\r\n\t\treturn this.coll.get(id);\r\n\t}\r\n\r\n\tgetAllLayersWithId() {\r\n\t\treturn this.coll.values();\r\n\t}\r\n}\n\n//# sourceURL=webpack://easyChart/./js/layeredCanvas.js?");

/***/ }),

/***/ "./js/models/CandleData.js":
/*!*********************************!*\
  !*** ./js/models/CandleData.js ***!
  \*********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ CandleData)\n/* harmony export */ });\nclass CandleData {\r\n    constructor(barArray) {\r\n        this.time = parseInt(barArray[0]);\r\n        this.open = parseFloat(barArray[1]);\r\n        this.high = parseFloat(barArray[2]);\r\n        this.low = parseFloat(barArray[3]);\r\n        this.close = parseFloat(barArray[4]);\r\n        this.vol = parseFloat(barArray[5]);\r\n        this.volFiat = parseFloat(barArray[6]);\r\n        this.otherInfo = {};\r\n        this.otherInfo.shapes = [];\r\n        this.barWidth = -1;\r\n\r\n        if (this.close === null) {\r\n            this.complete = false;\r\n        }\r\n        else {\r\n            this.complete = true;\r\n        }\r\n    }\r\n\r\n}\n\n//# sourceURL=webpack://easyChart/./js/models/CandleData.js?");

/***/ }),

/***/ "./js/ochlParser.js":
/*!**************************!*\
  !*** ./js/ochlParser.js ***!
  \**************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ toNonStringObj)\n/* harmony export */ });\n/* harmony import */ var _models_CandleData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models/CandleData.js */ \"./js/models/CandleData.js\");\n\r\n\r\nfunction toNonStringObj(array) {\r\n    if (!(array instanceof Array)) {\r\n        throw new Error(\"the object to parse needs to be arrray.\");\r\n    }\r\n    var newArr = [];\r\n\r\n    array.forEach(element => {\r\n        var cls = new _models_CandleData_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](element);\r\n        newArr.push(cls);\r\n    });\r\n\r\n    return newArr;\r\n}\n\n//# sourceURL=webpack://easyChart/./js/ochlParser.js?");

/***/ }),

/***/ "./js/onMouesDrag.js":
/*!***************************!*\
  !*** ./js/onMouesDrag.js ***!
  \***************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ OnMouseDragEvent)\n/* harmony export */ });\n\r\nfunction OnMouseDragEvent(targetElementOrID, callbackObj) {\r\n    /*if (!(targetElement instanceof HTMLDivElement) || !(targetElement instanceof HTMLCanvasElement)) {\r\n        throw new Error(\"Target element is not html div element\");\r\n    }*/\r\n\r\n    var targetElement = targetElementOrID\r\n    if (typeof targetElementOrID == typeof \"a\") {\r\n        targetElement = document.getElementById(targetElementOrID);\r\n        if (!targetElement) {\r\n            throw new Error(\"Element with id: \" + targetElementOrID + \" does not exists\");\r\n        }\r\n    }\r\n\r\n    targetElement.deltaTime = 50;\r\n    targetElement.mouseDownn = false;\r\n    targetElement.lastUpdate = Date.now();\r\n    targetElement.prevMouseDetail = undefined;\r\n    targetElement.currentEventDetail = undefined;\r\n    targetElement.callbackObj = callbackObj;\r\n\r\n    targetElement.addEventListener(\"mousedown\", (e) => {\r\n        var obj = e.currentTarget;\r\n        document.mouseDownnElement = obj;\r\n        obj.mouseDownn = true;\r\n        obj.prevMouseDetail = {\r\n            x: e.screenX,\r\n            y: e.screenY,\r\n        };\r\n    });\r\n\r\n    document.addEventListener(\"mouseup\", (e) => {\r\n        var obj = document.mouseDownnElement;\r\n        if (obj == undefined) {\r\n            return;\r\n        }\r\n        obj.mouseDownn = false;\r\n        obj.prevMouseDetail = {\r\n            x: 0,\r\n            y: 0,\r\n        };\r\n\r\n        document.mouseDownnElement = undefined;\r\n    });\r\n\r\n    targetElement.addEventListener(\"mousemove\", (e) => {\r\n        var obj = e.currentTarget;\r\n        if (obj.mouseDownn === true && (Date.now() - obj.lastUpdate >= obj.deltaTime)) {\r\n            e.prevMouseDetail = obj.prevMouseDetail;\r\n            obj.lastUpdate = Date.now();\r\n            obj.callbackObj.cb(e, obj.callbackObj.parent);\r\n            obj.prevMouseDetail = {\r\n                x: e.screenX,\r\n                y: e.screenY,\r\n            };\r\n        }\r\n\r\n    });\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\n\n//# sourceURL=webpack://easyChart/./js/onMouesDrag.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./js/dataRenderer.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});